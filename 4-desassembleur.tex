\itodo{Intro : on a vu qu'on cherche à séparer le code des données, quels sont les possibilités pour y arriver ?}
\todo[inline]{Statique / dynamique : Avantages et inconvénients des deux (couverture, précision, complétude)}
Dans le domaine de l'analyse de code, on parle d'analyse dynamique lorsque le fichier binaire à analyser est exécuté au moins partiellement et que l'analyse consiste à observer une ou des exécutions du programme. Au contraire lors d'une analyse statique on cherche à inférer des propriétés sur le programme sans l'exécuter.

Les deux techniques permettent de récupérer du code assembleur à partir du programme et donc de réaliser un désassemblage et de reconstruire un graphe de flot de contrôle.
L'avantage de l'analyseur dynamique est que, puisqu'il travaille sur une exécution spécifique du programme, il est précis : les instructions qui sont exécutées doivent être inclues dans le désassemblage.
Par contre il n'est pas complet vu qu'il ne suivra pas des branches du programme qui pourraient être utilisées si leurs conditions étaient vérifiées. À l'inverse un analyseur statique n'est pas précis et ne peut en général pas être complet à cause de l'impossibilité de prédire certaines cibles de sauts dynamiques.

\paragraph{Difficulté théorique du désassemblage.}
~\\\ijym{reprendre la preuve}
\itodo{Pb de l'arrêt: il existe HALT / HALT(P) = 1 ssi quelle que soit l'entrée I, P(I) termine ?}
\itodo{Pb du désassemblage : borne min : intersection de CODE(P,I), borne max : union}
\itodo{borne min ~ arrêt ?}
On a vu que le problème du désassemblage tient dans la difficulté de séparer les parties de code potentiel des parties de données.
Plus précisément le but du désassemblage d'un programme P est alors de déterminer l'ensemble des adresses $a$ du programme pour lesquelles il existe une entrée I telle que l'exécution de P(I) atteint $a$.
Nous citons ici un argument tiré de la thèse de Joan Calvet \cite{Calvet2013} montrant le caractère indécidable de ce problème en réduisant le problème de l'arrêt à celui-ci.

Supposons que le problème soit décidable et notons $CODE$ le programme tel que, pour tout programme P, $CODE(P)$ est l'ensemble des adresses des instructions de P atteignables lors de l'exécution de P. Pour tout programme P et toute entrée I à P, on peut définir le programme P' suivant qui ne prend pas d'entrée :

\begin{center}
\begin{tabular}{|l|l|}
\hline
Adresse & Commande \\
\hline
0 & P(I)\\
% $\alpha$ & halt \\
\hline
\end{tabular}
\end{center}

On remarque que $CODE(P')$ contient exactement les adresses des instructions de P 
Deux cas sont alors possibles.
\begin{itemize}
 \item Soit il existe $\alpha\in CODE(P')$ tel que l'instruction à l'adresse $\alpha$ est l'instruction d'arrêt \texttt{halt} et dans ce cas l'exécution atteint l'adresse $\alpha$ donc le programme P termine sur l'entrée I.
 \item Dans le cas contraire aucune instruction d'arrêt n'est atteignable et donc le programme P ne termine pas sur l'entrée I.
\end{itemize}
\begin{itemize}
 \item Soit $\alpha\in\ CODE(P')$ et dans ce cas l'exécution atteint l'adresse $\alpha$ donc le programme P termine sur l'entrée I.
 \item Soit $\alpha\notin\ CODE(P')$ donc le programme P ne termine pas sur l'entrée I.
\end{itemize}
~\\
On en déduit donc que le désassemblage permet de résoudre le problème de l'arrêt qui est pourtant connu pour être indécidable ; c'est absurde.
Ainsi le problème du désassemblage est indécidable.

\section{État de l'art}
\subsection{Désassemblage statique et chevauchement de code}
Pour pallier à l'incomplétude d'un parcours récursif et au manque de précision d'un parcours linéaire, plusieurs approches ont été proposées.

\paragraph{Parcours spéculatif.}
Le parcours récursif étant moins sensible à des obscurcissements très simples comme l'injection de code mort, il est souvent pris comme point de départ dans les recherches sur le désassemblage statique.
Une fois une première recherche de code avec un parcours récursif effectuée, les octets restants peuvent subis un parcours linéaire qui cherchera à déterminer s'ils sont du code ou des données à l'aide d'heuristiques.
Une de ces approche évalue la probabilité qu'une suite d'octets soit effectivement du code en apprenant au préalable des suites d'octets codant réellement des instructions lancées lors de l'exécution de programmes \cite{KDF09}.
On appelle cet enchaînement des deux parcours un parcours spéculatif.

Prasaf et Chiueh \cite{PC03}, après un premier désassemblage récursif, tentent d'identifier les adresses de début de fonctions assembleur à l'aide de la suite d'instruction \push\ \mov\ caractéristique de fonctions compilées avec la convention CDECL\todo{check}. Ils identifient également toutes les adresses où sont codées une instruction valide. À partir de ces adresses ils effectuent à nouveau un parcours récursif. Le risque est alors grand que des chemins parcourus ainsi soient invalident, ils éliminent les chemins qui n'aboutissent ni sur un \ret\ ni sur un \jmp\ puisqu'ils aboutissent du coup sur des données.

\paragraph{Chevauchement de code.}
Krügel, Roberston, Valeur et Vigna \cite{KruegelRVV04} proposent aussi de séparer le code en fonctions assembleur. Ils effectuent une première analyse récursive pour détecter le maximum d'instructions atteignables et, lorsque que deux ou plusieurs instructions atteignables se chevauchent, ils considèrent qu'il s'agit d'un conflit qui se résoudra par le choix d'une des instructions.
Leurs hypothèses sont : (i) les instructions ne peuvent pas se chevaucher, (ii) les sauts conditionnels peuvent être suivis ou non, (iii) le binaire peut contenir du code mort, et (iv) le code suivant une instruction \call\ n'est pas nécessairement accessible. Pour résoudre les conflits de chevauchement ils favorisent les instructions atteignables depuis le point d'entrée (que l'on sait accessible), puis ils considèrent qu'une instruction permettant d'atteindre directement deux instructions qui se chevauchent n'est pas valide et enfin ils favorisent les instructions les plus connectées au graphe de flot de contrôle.
Leur approche est un point de départ pour le désassemble de binaires obscurcis. Ils par exemple prennent en compte l'ajout de code mort et certaines modifications du flot de contrôle.

Schwarz, Debray et Andrews \cite{SDA02} introduisent un parcours linéaire capable de détecter certaines injections de données dans le code, comme les tables de saut (souvent présent dans du code compilé en C ou C++). Ils proposent de combiner les parcours récursifs et linéaires pour détecter les anomalies dans le désassemblage. Si, au sein d'une fonction, une instruction provenant du désassemblage récursif chevauche une instruction provenant du désassemblage linéaire, le désassemblage de la fonction est considéré comme contenant une erreur.

Partant du principe qu'un désassemblage correct ne contient pas de chevauchement de code, ces deux approches sont pas satisfaisante pour désassembler des binaires utilisant du chevauchement de code, tels les programmes protégés avec \telock.

Dans sa thèse, Kinder \cite{Kinder10} indique que si la technique de désassemblage ne prend pas de contrainte de d'alignement du code et réalise des désassemblages atomiques d'une seule instruction à la fois à partir de chaque adresse, alors on peut voir deux instructions qui se chevauchent comme indépendantes. Effectivement les travaux présentés dans cet état de l'art ainsi que les désassembleurs existants prennent pour hypothèse que le code ne doit pas se chevaucher alors que nous avons représenté les chevauchements de \telock\ et UPX très simplement. L'hypothèse d'alignement permet en général de simplifier les critères de désassemblage et est justifiée par la non occurrence de ce phénomène dans des programmes légitimes.




\ijym{+ de biblio}


\section{Analyse dynamique et auto-modification}
\section{Analyse statique et chevauchement de code}
\section{Codisasm}