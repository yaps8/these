% \section{Contexte et enjeux}
% \todo[inline]{Ajouter:
% Attaque -> Malware\\
% Marché des vulnérabilités, des malwares\\
% }
% Un logiciel opérant sur un ordinateur est dit malveillant s'il réalise volontairement des opérations allant à l'encontre de l'intérêt de l'utilisateur et ce à l'insu de celui-ci.
Un logiciel malveillant réalise volontairement des opérations allant à l'encontre de l'intérêt de l'utilisateur. 
Certaines de ces actions peuvent être objectivement malveillantes comme c'est le cas avec Stuxnet qui vise des éléments d'un système de contrôle industriel afin de le rendre inutilisable. 
% Les administrateurs utilisent quotidiennement des programmes de gestion de machine à distance. 
Un logiciel malveillant qui vise à fournir à un attaquant un accès à distance ne diffère pas fondamentalement, en termes de fonctionnalités, d'un logiciel légitime utilisé par un administrateur.
La différence entre les deux est que l'administrateur n'est pas au courant de l'installation du logiciel malveillant et ne peut pas le contrôler.
Nous proposons donc la définition suivante pour un logiciel malveillant.
\\

\textit{Un logiciel est dit malveillant s'il réalise volontairement des opérations allant à l'encontre de l'intérêt de l'utilisateur, et ce à l'insu de celui-ci.}
\\ 

Les actions malveillantes peuvent être de différentes natures. On parle d'atteinte à la confidentialité lorsque des données privées sont obtenues par l'attaquant, d'atteinte à l'intégrité lorsque de l'information présente sur le système attaqué est altérée par l'attaquant et d'atteinte à la disponibilité du système si l'attaquant rend le système inutilisable ou plus difficile à opérer.

% Les logiciels malveillants s'attaquent en général à la confidentialité et la disponibilité du système bien que les outils d'administration à distance soient capables, une fois la machine infectée, d'attaquer ces trois aspects de la sécurité de la machine.

En général un logiciel malveillant diffère d'un logiciel légitime en ce qu'il cherche à dissimuler son existence et son action sur le système. Il déploie à cette fin des techniques de protection logicielle rendant son analyse plus difficile que celle du programme légitime.
On appelle alors \emph{charge utile} l'action finale d'une attaque sur le système compromis.
Le programme malveillant cherche à exécuter cette charge utile sur sa cible tout en la dissimulant à des analystes éventuels.


\section*{Détection de logiciels malveillants}
Les premiers travaux traitant de virologie informatique datent de 1986 avec Cohen \cite{Cohen86} puis Adleman \cite{Adleman88} en 1988. Ils s'intéressent particulièrement au comportement auto-reproducteur de certains programmes : déterminer si un programme a un comportement auto-reproducteur est un problème indécidable. De même il n'existe pas de programme capable de décider, sans jamais se tromper, si un programme analysé a un comportement malveillant.

Les décennies qui ont suivi ont vu apparaître différentes techniques de détection partielles dont la plus répandue est l'analyse de signatures syntaxiques. Ces approches consistent dans un premier temps à extraire d'un corpus de logiciels connus pour être malveillants certaines caractéristiques : la présence de certaines chaînes de caractères dans le fichier contenant le programme ou l'utilisation de certaines instructions dans un ordre précis, par exemple. Dans un second temps, pour classifier un logiciel inconnu, on regarde s'il possède une des caractéristiques extraites de ce corpus.
Cette technique possède le double avantage d'être rapide et de générer peu de fausses alarmes.

Cependant chaque souche originale d'un logiciel malveillant est généralement déclinée en de nombreuses versions dont les caractéristiques varient. Ces souches forment une famille de logiciels malveillants. Pour éviter la détection par signatures syntaxiques, il suffit souvent d'insérer du code inutile ou de réorganiser le code : le nouveau logiciel malveillant est identique fonctionnellement au code initial mais les signatures précédemment extraites n'y sont plus présentes.

Nous nous sommes alors intéressés à la technique de détection initiée par Kaczmarek \cite{BKM08} lors de sa thèse. Il s'agit d'une technique de détection par signatures basée sur la comparaison de graphes de flot de contrôles, c'est à dire du graphe structurant l'exécution du logiciel.
% \todo[inline]{exemple prog ->  CFG}

Dans la pratique, les logiciels malveillants sont souvent protégés par une technique d'empaquetage cachant complètement la charge utile à un analyste.
Aucune technique basée sur une observation passive du programme empaqueté ne peut permettre de prédire sa charge utile et donc de détecter s'il est malveillant.
De manière plus générale on parle d'obscurcissement lorsqu'un programme cherche à se protéger de l'analyse.

Afin de lutter contre différentes techniques d'obscurcissement, nous avons travaillé sur une méthode d'analyse hybride.
Dans un premier temps nous exécutons le programme pour lui faire dépaqueter les parties empaquetées. Dans un second temps nous analysons statiquement les parties du programme qui n'ont pas été exécutées et nous y identifions d'autres méthodes d'obscurcissement puis y effectuons une détection.

\section*{Problèmes de recherche}
La principale difficulté rencontrée lors de l'analyse d'un logiciel malveillant est qu'il est auto-modifiant : un programme empaqueté se décompresse en réécrivant sur lui-même en mémoire. L'auto-modification complexifie grandement la sémantique du programme puisqu'une instruction peut-être amenée à être modifiée au cours de l'exécution de celui-ci.

% \begin{pb}
%  Définir une sémantique et une technique d'analyse compatible avec l'auto-modification.
% \end{pb}

Afin de comprendre cette technique il est nécessaire d'utiliser une sémantique compatible avec l'auto-modification.
Nous avons repris les sémantiques définies par Reynaud \cite{Reynaud2010} et Calvet \cite{Calvet2013} séparant l'exécution d'un programme auto-modifiant en vagues. Chacune des vagues représente une étape d'exécution dans laquelle le programme n'est pas modifié. Cette représentation permet d'analyser chaque vague indépendamment des autres et d'articuler l'analyse d'un programme autour d'une trace d'exécution particulière.
Nous avons implémenté un émulateur de code \xq\ auto-modifiant qui est capable de reconstruire les vagues de la trace émulée.

% La contribution de cette thèse réside dans une sémantique et un algorithme permettant une analyse bornée de toutes les traces d'exécution possibles d'un programme. 

Nous avons ensuite cherché à désassembler un programme obscurci. Le but est de déterminer l'ensemble du code atteignable en étant à la fois correct (on doit couvrir tout le code potentiel) et précis (le code désassemblé doit pouvoir être exécuté). 

\begin{pbb}
 Désassembler et reconstruire le graphe de flot de contrôle d'un programme obscurci.
\end{pbb}

Puisque notre objectif est de comparer les graphes de programmes connus et inconnus, nous utilisons le désassemblage pour reconstruire un graphe de flot de contrôle du programme analysé.
Notre contribution à ce problème est la définition et l'implémentation d'un désassembleur hybride partant d'une trace d'exécution et permettant de reconstruire le graphe de flot de contrôle de chacune des vagues du binaire à l'aide d'une analyse statique.
\\ 

Par ailleurs la comparaison des graphes de flot de contrôle, ou analyse morphologique, consistait en la détection d'isomorphismes de graphes entre des parties des graphes de flot considérés. 
L'algorithme utilisé à l'origine fonctionnait par reconnaissance d'arbres à l'aide d'un automate d'arbres. Il n'existait pas de cadre formel définissant les objets détectés par cette analyse. Sans cadre formel il était difficile de mesurer les performances des implémentations utilisées en termes de précision des résultats.

\begin{pbb}
 Formaliser et optimiser la reconnaissance de graphes dans l'optique de la détection de programmes malveillants.
\end{pbb}

Notre travail a permis de dégager la notion de site. Les sites sont des sous-graphes particuliers du graphe de flot de contrôle et sont l'entité atomique que nos algorithmes de détection d'isomorphismes cherchent à faire correspondre entre plusieurs programmes à analyser. Nous avons élaboré un algorithme correct et rapide pour des petites bases de logiciels malveillants ainsi qu'un algorithme sous-optimal mais donnant de bons résultats et dont le temps d'exécution ne dépend pas de la taille de la base.

\section*{Contributions}
Nous avons contribué à l’analyse de programmes obscurcis de deux manières. 
D’une part nous avons décrit un langage assembleur disposant d’une sémantique concrète compatible avec l’exécution de programmes auto-modifiants.
Nous avons étendu BAP, une plateforme d’analyse de binaires existante, pour lui permettre d’évaluer des programmes auto-modifiants.
Nous avons également formalisé le problème du chevauchement de code et étudié l’usage que les programmes obscurcis font de cette méthode de protection. 
D’autre part nous avons proposé une technique de désassemblage consistant à effectuer une analyse dynamique que l’on complète à l’aide de techniques d’analyse statique. 
Cette technique a pour objectif de reconstruire un graphe de flot de contrôle dont nous avons défini la forme idéale.

Nous avons également contribué à l’analyse morphologique en formalisant le sous-problème d’isomorphisme de sous-graphes qu’elle cherche à résoudre. Nous avons développé et implémenté un algorithme correct et plus rapide que l'approche existante pour résoudre ce problème ainsi qu’un algorithme incorrect mais de temps d’exécution constant. Nous avons enfin proposé une application de la technique d’analyse morphologique au domaine de la détection de similarités logicielles \cite{REAT12,mal12} et démontré la technique sur quelques logiciels malveillants spécifiques \cite{sstic13,mal13}.
\section*{Organisation du document}

Nous commencerons, dans une première partie, par définir les notions d'assembleur et de désassemblage qui seront utilisées dans la suite du manuscrit, puis détaillerons une technique d'analyse dynamique, puis statique, de programmes obscurcis. Cette partie se terminera par la combinaison des deux approches et la présentation de notre outil de désassemblage.

La seconde partie portera plus particulièrement sur l'analyse morphologique et les algorithmes de comparaison de graphes. Nous reviendrons sur les applications d'une telle méthode à la détection de programmes malveillants, à la détection de similarités logicielles et à l'analyse pratique de programmes malveillants avec l'exemple de \duqu\ et \stux.
