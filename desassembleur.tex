

% \section{Analyse dynamique et auto-modification}
% L'analyse dynamique consiste donc à se baser sur une ou des exécutions particulières d'un programme pour inférer des propriétés sur son fonctionnement.
% Elle demande donc de se munir d'une langage modélisant le fonctionnement de la machine durant l'exécution du programme, d'une sémantique concrète de l'assembleur utilisé et de lancer l'évaluation sémantique du programme sur une ou plusieurs entrées.
% Les entrées d'un programme sont par exemple les paramètres passés lors de l'appel au programme, l'état de la machine lors du démarrage, les données lues depuis la mémoire et les saisies faites par l'utilisateur au clavier ou à la souris lors de l'exécution s'il s'agit d'une application dotée d'une interface graphique.
% Dans cette partie nous reprendrons la sémantique simplifiée pour un langage assembleur définie au chapitre précédent et expliquerons comment séparer une exécution d'un programme auto-modifiant en plusieurs sous-exécution non auto-modifiantes afin d'utiliser des techniques standard d'analyse sur chacune de ces sous-exécutions.

Nous avons précédemment détaillé plusieurs techniques d'obscurcissement de code. 
Nous avons décrit des méthodes d'analyse de programmes \nsm\ présentant des chevauchements de code et une méthode permettant de ramener l'analyse d'un programme \sm\ à l'analyse de plusieurs programmes \nsms\ par découpage en instantanés.

Dans ce chapitre nous présentons une méthode d'analyse combinant l'approche dynamique pour gérer les programmes \sms\ et une analyse statique de chaque sous programme considéré à partir d'un instantané et de la trace d'exécution.

\section{Désassemblage parfait}
% \subsection{}
Nous avons, au chapitre \ref{chap:assembleur}, défini le désassemblage parfait d'un programme \nsm\ comme la donnée de l'ensemble des adresses auxquelles des instructions peuvent être atteintes lors de l'exécution.
Dans le cas d'un programme \sm, cette définition n'est pas suffisante puisque l'instruction présente à une adresse dépend du contexte d'exécution et des éventuelles modifications qui ont été faites à cette adresse.

Nous considérons toujours que la donnée que l'analyste cherche à
déterminer et représenter est l'ensemble des exécution possibles du
programme : nous notons $E_T$ l'ensemble des traces d'exécution possibles.
En particulier une entrée spécifique provoque une exécution que nous observons sous la forme d'une trace.
Cette trace peut être découpée en niveaux d'exécution et chaque vague est le désassemblage parfait de l'instantané.

Le désassemblage, pris au sens de l'opération inverse de l'assemblage,
consiste à déterminer les adresses contenant des instructions, les
autres contenant des données.
Au sein d'une exécution les octets sur lesquelles une instruction ayant
un niveau d'exécution strictement supérieur à 1, c'est à dire que ces
octets ont été modifiés avant que l'instruction ne soit exécutée, ne
sont présents dans la représentation d'origine du programme qu'en temps
que données.
Ainsi le désassemblage parfait d'un programme \sm\ ne prend en compte
que les instructions exécutées avec un le niveau d'exécution 1
(définition \ref{def:desassemblage_parfait_sm}).

\begin{defi}
 Étant donné un programme P \sm\ et l'ensemble de ses traces d'exécution
$E_T$, le désassemblage parfait de P est l'ensemble des adresses où une
instruction de niveau d'exécution 1 est exécutée dans au moins une
trace, c'est à dire~$\{a, \exists\ T\in E_T, \exists\ (i, X, D)\in T, X=1,\ $\da{D}$=a\}$.
\label{def:desassemblage_parfait_sm}
\end{defi}

\subsection{Graphe de flot de contrôle parfait}
Le graphe de flot de contrôle ne peut plus se contenter de représenter
une instruction par son adresse puisque plusieurs instructions
différentes peuvent être présentes à la même adresse.
Le graphe de flot de contrôle parfait est alors le graphe dont les
sommets sont des couples $(a, I)$ où \adr{a} est une adresse et $I$ une
instruction assembleur. Il y a un arc entre deux sommets si le second
suit directement le premier dans une trace d'exécution (définition
\ref{def:cfg_parfait_sm}).

\begin{defi}
 Étant donné un programme \sm\ P et l'ensemble de ses traces d'exécution
$E_T$, le graphe de flot de contrôle parfait de P est le graphe orienté
$G=(V, E)$ tel que :
 \begin{itemize}
  \item $V=\{(\mda{D}, \mdi{D}),  (i, X, D)\in E_T\}$
  \item $((a_1, I_1), (a_2, I_2))\in E\ si\ et\ seulement\ si\ (a_1,
I_1)\ et\ (a_2, I_2)\ se\ suivent\ dans\ une\ trace\ : \exists T\in
E_T,\ i\in \BN, (i, X_1, D_1)\ et\ (i+1, X_2, D_2)\in T\ avec\
$\da{D_1}$=a_1,\ $\di{D_1}$=I_1,$~\da{D_2}$=a_2,\ $\di{D_2}$=I_2$.
 \end{itemize}
\label{def:cfg_parfait_sm}
\end{defi}

Le problème de cette définition d'un GFC pour un programme \sm\ est qu'%e souvent les vagues se suivent et ont peu de rapport les unes avec les autres.
elle ne permet pas de visualiser l'enchaînement des vagues et peut conduire à une interprêtation biaisée des exécutions possibles.

\paragraph{Exemple.}
Prenons le programme donné en figure \ref{fig:sm_asm} dont le graphe de flot de contrôle construit par analyse statique à l'aide d'un parcours récursif est en figure \ref{fig:sm_cfg_statique}.

\begin{figure}[h]
\begin{center}
% \subfigure[]{
\begin{tabular}[b]{|l|l|l|l|}
\hline
Adresse & Octets & Instruction & Instruction écrite\\ 
\hline
 8048060 <debut>  &  31 ff             &  xor    edi,edi		& \\
 8048062  &  40                        &  inc    eax			& \\
 8048063  &  74 07                     &  je     804806c <si\_zero> 	& \\
 	  &			       &				& \\
 8048065  &  bf 02 00 00 00            &  mov    edi, 0x2 		& \\
 804806a  &  eb f4                     &  jmp    8048060 <debut> 	& \\
	  &			       &				& \\
 804806c <si\_zero> &  bf 01 00 00 00  &  mov    edi, 0x1 		& \\
 8048071  &  bb 60 80 04 08            &  mov    ebx, 0x8048060 	& \\
 8048076  &  66 c7 03 47 00            &  mov    [ebx], 0x47 		& inc edi\\
 804807b  &  66 c7 43 01 47 00         &  mov    [ebx+0x1], 0x47	& inc edi \\
 8048081  &  66 c7 43 03 c3 00         &  mov    [ebx+0x3], 0xc3	& ret \\
 8048087  &  eb d7                     &  jmp    8048060 <debut> 	& \\
\hline
\end{tabular}
\caption{Code \sm}
\label{fig:sm_asm}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\textwidth]{supports/disas_sm/ex2_statique.pdf}
% \label{fig:sm_cfg_statique}
% }
\caption{GFC par analyse statique et récursive}
\label{fig:sm_cfg_statique}
\end{center}
\end{figure}

% \FloatBarrier

La branche du saut effectué à l'adresse \adr{0x8048063} dans le cas où \eax\ est différent de zéro revient vers le point d'entrée, incrémente \eax\ et passe à nouveau dans le saut conditionnel. Cette boucle provoquera à terme un dépassement d'entier sur la valeur \eax\ qui sera remise à zéro et l'autre branche du saut sera appelée.
Cette seconde branche a pour effet de modifier les instructions aux adresses \adr{0x8048060}, \adr{0x8048061} et \adr{0x8048063} pour y placer les instructions \texttt{inc edi}, \texttt{inc edi} et \texttt{ret} respectivement, puis de sauter sur l'adresse \adr{0x8048060}, provoquant l'exécution des instructions écrites ainsi que de l'instruction \texttt{inc eax}, non modifiée.

Ainsi toutes les exécutions possibles, paramétrées par la valeur initiale d'\eax, bouclent sur la branche conditionnelle un nombre fini, qui peut être nul, de fois et exécutent la seconde branche, qui met la valeur 1 dans \edi, provoque une auto-modification, incrémente \edi\ deux fois puis quitte la fonction. Dans toutes les exécutions possibles la valeur finale de \edi\ est toujours 3.

Le GFC parfait de ce programme est donné en figure \ref{fig:sm_cfg_parfait}. En raison du mélange des instructions à différents niveaux d'exécution, il n'est pas possible de distinguer les vagues d'exécution et un analyseur statique simple approxime la valeur de \edi\ à 2 ou 3.

\begin{figure}[h]
\begin{center}
  \includegraphics[width=0.7\textwidth]{supports/disas_sm/ex2_parfait.pdf}
\end{center}
\caption{GFC parfait}
\label{fig:sm_cfg_parfait}
\end{figure}



Cette difficulté n'est pas intrinsèque aux programmes \sm\ et provient du fait même que le graphe de flot de contrôle est sur une \sura\ de l'ensemble des exécutions possibles. Il est cependant exacerbé dans le cas des programmes \sm\ puisque souvent les vagues successives n'ont que peu de code commun entre elles et il n'est pas cohérent de les mélanger dans le CFG.

\FloatBarrier
\subsection{Graphe de flot de contrôle incluant les vagues}

\begin{figure}[h]
\begin{center}
\begin{tikzpicture}[
%   tlabel/.style={pos=0.4,right=-1pt},
%   every node/.style={color=black, circle, minimum size=10mm, draw=black, align=center},
%   edge from parent/.style={->, draw=black},
%   level 1/.style={sibling distance=30mm, level distance=15mm},
  thick
]
\node (ROOT) {$S_1$}
% \node (S11){Site 1};
child {node (S2) {$S_2$}
child{node (S3) {$S_3$}
child {node (S4) {$S_7$}
  child {node (S5) {$S_5$}}
  child {node (S6) {$S_6$}}
}
}
child{node (S7) {$S_7$}
child {node (S8) {$S_8$}
}
}
child {node (S9) {$S_9$}}
};
% \draw (S4) -> (S5);
\path (ROOT) edge [->] (S2);
\path (S2) edge [->] (S3);
\path (S2) edge [->] (S7);
\path (S2) edge [->] (S9);
\path (S3) edge [->] (S4);
\path (S4) edge [->] (S5);
\path (S4) edge [->] (S6);
\path (S7) edge [->] (S8);
\path (S8) edge [->] (S6);
\node[draw=none, left=2.5cm of ROOT.west, anchor=east, text width=4cm, minimum size=4cm] (V1){Niveau d'exécution 1};
\node[draw=none, below=15mm of V1.north, text width=4cm, minimum size=4cm] (V2){Niveau d'exécution 2};
\node[draw=none, below=15mm of V2.north, text width=4cm, minimum size=4cm] (V3){Niveau d'exécution 3};
\node[draw=none, below=15mm of V3.north, text width=4cm, minimum size=4cm] (V4){Niveau d'exécution 4};
\node[draw=none, below=15mm of V4.north, text width=4cm, minimum size=4cm] (V5){Niveau d'exécution 5};
% \node[draw=none, left=4cm of ROOT.west, anchor=east, text width=1.1cm, minimum size=1.2cm] (V1){Vague 1};
% \node[draw=none, left=4cm of ROOT.west, anchor=east, text width=1.1cm, minimum size=1.2cm] (V1){Vague 1};
% \node[draw=none, left=4cm of ROOT.west, anchor=east, text width=1.1cm, minimum size=1.2cm] (V1){Vague 1};
\end{tikzpicture}
\end{center}
\caption{Arbre représentant les différents instantanés, et leur niveau d'exécution, des traces d'exécution}
\label{fig:arbre_vagues}
\end{figure}

\FloatBarrier
\subsection{Graphe de flot de contrôle paramétré par une exécution}
Nous proposons une représentation du GFC basée sur une exécution particulière et son découpage en différents niveaux d'exécution.
Nous donnons la définition d'une exécution (définition \ref{def:execution}), issue du résultat de l'analyse dynamique définie au chapitre précédent. L'exécution d'un programme sur une entrée I est caractérisée, via l'algorithme \ref{algo:analyse_dyn_vagues}, par le couple $(T, S)$ où $T$ est une trace et $S$ une liste d'instantanés d'exécution, un pour chaque niveau d'exécution.

\begin{defi}
 Soit un programme P prenant une entrée et ayant pour point d'entrée $ep$.
 $(T, S)$ est une exécution de P si et seulement si il existe une entrée I telle que (T, S)=\texttt{exécution(P, I, ep)}.
 
 On note $E_X$ l'ensemble des exécutions de P : $E_X=\bigcup_I\{\texttt{exécution(P, I, ep)}\}$.
\label{def:execution}
\end{defi}

L'exécution choisie, dite de référence, consiste donc en une trace et un enchaînement d'instantanés de chaque niveau d'exécution.
Chaque instantané est pris comme un programme ayant pour point d'entrée la première instruction de la trace ayant le niveau d'exécution correspondant et un point de sortie étant la dernière instruction ayant ce même niveau d'exécution.

Nous appelons GFC paramétré par cette exécution l'union des GFC parfaits de chaque de ces instantanés dans lequel les sommets sont caractérisés par le niveau d'exécution de l'instantané, une adresse et une instruction assembleur.
Formellement cette définition est possible si l'on se restreint à vouloir construire le GFC des seules exécutions dont les instantanés sont identiques à ceux de l'exécution de référence, on dit alors que ces exécutions sont compatibles (définition \ref{def:executions_compatibles}).

\begin{defi}
 Soit un programme P et $(T, S)$ et $(T', S')$ deux exécutions de P.
 $(T, S)$ et $(T', S')$ sont dites compatibles si et seulement si $S=S'$.
\label{def:executions_compatibles}
\end{defi}

Le GFC paramétré (définition \ref{def:cfg_param_sm}) représente chaque instruction contenue dans une trace dont l'exécution est compatible avec l'exécution de référence comme un sommet en prenant en compte son niveau d'exécution, son adresse et l'instruction assembleur. Deux sommets sont reliés par un arc si, dans une trace d'une exécution compatible, leurs deux instructions se suivent immédiatement.

\begin{defi}
 Étant donné un programme P \sm, $(T, S)$ une exécution de P et $E_C$ l'ensemble des exécutions de P compatibles avec $(T, S)$.
 Nous appelons GFC paramétré par $T$ le graphe $G=(V, E)$ tel que :
 \begin{itemize}
  \item $V=\{(X,\ $\da{D}$,\ $\di{D}$), (i, X, D)\in T',\ (T', S')\in E_C \}$%\in E_C, \exists\ (i, X, D)\in T',\
%$\da{D}$=a,\ $\di{D}$=I\}$
  \item $((X_1, a_1, I_1), (X_2, a_2, I_2))\in E$ si et seulement si $(X_1, a_1,
I_1)\ et\ (X_2, a_2, I_2)$ se suivent dans une trace : $\exists (T', S')\in
E_C,\ i\in \BN, (i, X_1, D_1)\ et\ (i+1, X_2, D_2)\in T$ avec \da{D_1}$=a_1,\ $\di{D_1}$=I_1,$~\da{D_2}$=a_2,\ $\di{D_2}$=I_2$.
 \end{itemize}
\label{def:cfg_param_sm}
\end{defi}


Un tel GFC pour le programme \sm\ précédent est donné en figure \ref{fig:sm_cfg_vagues} : l'exécution prise en compte est celle démarrant avec \eax=-2. La boucle directe est exécutée une fois, puis comme \eax=0, la partie auto-modifiante est activée. Dans l'exemple choisi ici, toutes les exécution partagent le même découpage en vagues et le GFC est séparé en deux GFC partiels (définition \ref{def:GFC_partiel}), celui de la vague 1 et celui de la vague 2.

\begin{defi}
 On appelle GFC partiel paramétré par une exécution $(T, S)$ et un instantané du niveau d'exécution $X$ le GFC paramétré par $T$ restreint aux sommets dont le niveau d'exécution est $X$.
\label{def:GFC_partiel}
\end{defi}


% \begin{defi}
%  Étant donné un programme \sm\ P et une trace d'exécution $T$, le graphe de flot de contrôle de P paramétré par $T$ est $G=(V, E)$ tel que :
%  \begin{itemize}
%   \item $V=\{(a, I),  \exists\ T\in E_T, \exists\ (i, X, D)\in T,\
% $\da{D}$=a,\ $\di{D}$=I\}$
%   \item $((a_1, I_1), (a_2, I_2))\in E\ si\ et\ seulement\ si\ (a_1,
% I_1)\ et\ (a_2, I_2)\ se\ suivent\ dans\ une\ trace\ : \exists T\in
% E_T,\ i\in \BN, (i, X_1, D_1)\ et\ (i+1, X_2, D_2)\in T\ avec\
% $\da{D_1}$=a_1,\ $\di{D_1}$=I_1,$~\da{D_2}$=a_2,\ $\di{D_2}$=I_2$.
%  \end{itemize}
% \label{def:cfg_param_sm}
% \end{defi}

\begin{figure}[h]
\begin{center}
  \includegraphics[width=0.6\textwidth]{supports/disas_sm/ex2_vagues.pdf}
\end{center}
\caption{GFC paramétré par l'exécution démarrant avec \eax=-2}
\label{fig:sm_cfg_vagues}
\end{figure}


L'idée consiste donc à obtenir une exécution particulière d'un programme puis à augmenter la couverture de code à l'aide d'une analyse statique sur chaque instantané de l'exécution. Nous discuterons de la pertinence de cette approche.

\FloatBarrier
\subsection{Revue de littérature}
Anckaert, Madou et Bosschere \cite{AMB06} proposent d'introduire la représentation sous forme d'octets de chaque instruction au sein du graphe de flot de contrôle et d'ajouter aux arcs les conditions sur les octets en mémoire. Sur l'exemple précédent, leur GFC, présenté en figure \ref{fig:sm_cfg_parfait_amb}, est identique au GFC parfait mais il est alors possible de différencier les chemins selon l'état de la mémoire et donc plus précis pour une analyse automatique.
En fait le graphe qu'ils représentent est un automate, permettant de compléter la notion d'automate de flot de contrôle introduit comme extension au graphe de flot de contrôle \cite{HJMS02} pour des programmes \sms.

\begin{figure}[h]
\begin{center}
  \includegraphics[width=0.8\textwidth]{supports/disas_sm/ex2_parfait_amb.pdf}
\end{center}
\caption{GFC parfait augmenté des octets et des conditions de transition}
\label{fig:sm_cfg_parfait_amb}
\end{figure}

\FloatBarrier
\section{Approche hybride}
% Nous avons vu comment séparer une trace d'exécution en plusieurs sous-traces définissant des vagues d'exécution.
% Chaque sous trace, au sein d'une vague, ne présente pas d'auto-modification.
% Nous décidons alors d'effectuer, pour chaque vague, un désassemblage par analyse statique en séparant le code en plusieurs \layers. Cette analyse est pertinente si les vagues ne présentent pas d'auto-modification. Nous discuterons ce point\todo{todo}.

Notre objectif est donc de construire un GFC paramétré par une exécution représentative du programme à analyser.
L'analyse dynamique du programme est faite selon l'algorithme \ref{algo:analyse_dyn_vagues} du chapitre précédent et fournit une trace d'exécution générale et un découpage de l'exécution en plusieurs instantanés de la mémoire.
Nous obtenons les traces et les instantanés par instrumentation avec Pin comme indiqué au chapitre précédent.
L'architecture générale du désassembleur est donnée par la figure \ref{fig:diag_codisasm}.

% \subsection{Architecture générale}
\begin{figure}[h]
\begin{center}
\scalebox{1}{
\begin{tikzpicture}[->,scale=1,>=stealth',thick]
\newcommand\espace{0.3cm}
\node[state] (BIN){Binaire};
\node[state, above right=2cm and 3.8cm of BIN] (TRACE) {Trace};
\node[state, below=1.8cm of TRACE.west, anchor=west] (I0) {Instantané 0};
\node[state, below=3.0cm of TRACE.west, anchor=west] (I1) {Instantané 1};
\node[state, below=4.2cm of TRACE.west, anchor=west] (Ip) {Instantané ...};
\node[state, below=5.4cm of TRACE.west, anchor=west] (In) {Instantané n};
% \node[state, right=1.4cm  of BIN] (ASM){ASM};
% \node[state, right=1.4cm of ASM] (IR){LI};

\node[state, right=4cm of I0] (V0) {Vague 0};
\node[state, below=1.2 of V0.west, anchor=west] (V1) {Vague 1};
\node[state, below=2.4 of V0.west, anchor=west] (Vp) {Vague ...};
\node[state, below=3.6 of V0.west, anchor=west] (Vn) {Vague n};

\coordinate [right=2cm of BIN.east] (DYN);
\coordinate [right=1.6cm of TRACE.east] (C0);
\coordinate [right=0.5cm of C0] (C1);
\coordinate [right=0.5cm of C1] (Cp);
\coordinate [right=0.5cm of Cp] (Cn);
% \coordinate [above=0.1cm of C1] (C10m);
% \coordinate [below=0.1cm of C1] (C10p);
\draw [-] (TRACE.east) -- (C0);
\draw [-] (C0) -- (C1);
\draw [-] (C1) -- (Cp);
\draw [-] (Cp) -- (Cn);
\draw (C0) -- ($(C0)+(0, -1.8cm)$);
\draw (C1) -- ($(C1)+(0, -3cm)$);
\draw (Cp) -- ($(Cp)+(0, -4.2cm)$);
\draw (Cn) -- ($(Cn)+(0, -5.4cm)$);
% \draw (C1) -- (C10m);
% \draw (C10p) -- ($(C1)+(0, -1.8cm)$);
\draw [-] (BIN.east) -- node[below left=3.0cm and -3.2cm, text width=4cm](DYNAMIC){Analyse dynamique} (DYN);
\draw (DYN) |- (TRACE.west);
\draw (DYN) |- (I0.west);
\draw (DYN) |- (I1.west);
\draw (DYN) |- (Ip.west);
\draw (DYN) |- (In.west);
\draw (I0) -- (V0);
\draw (I1) -- (V1);
\draw (Ip) -- (Vp);
\draw (In) -- node[below right=0.5cm and -1.8cm, text width=4cm](STATIC){Analyse statique} (Vn);
\node [fit={($(V0.north west) + (-0.2, 0)$) ($(V1) + (0.0, 0)$) ($(Vp) + (0.0, 0)$) ($(Vn.south east) + (0.3, 0)$)}, draw, label=GFC paramétré par la trace] {};
\end{tikzpicture}
}
\end{center}
\caption{Architecture générale du désassembleur hybride}
\label{fig:diag_codisasm}
\end{figure}

\paragraph{Pertinence de l'approche.}
L'exécution à partir de laquelle on cherche à reconstruire le GFC se doit d'être représentative d'une exécution standard du programme sur une machine cible.
Dans le cas des programmes malveillants on tente donc de se faire passer pour une machine ciblée par l'attaquant pour laisser le programme mener son attaque. 
À part les informations provenant du système d'exploitation, un programme malveillant ne prend en général pas d'entrée et ne nécessite pas d'interaction avec l'utilisateur. Une seule exécution devrait donc permettre d'analyser son comportement.
D'autre part la plupart des logiciels malveillants sont compilés sans comportement auto-modifiant et sont ensuite empaquetés. C'est le binaire empaqueté qui est obscurcis et auto-modifiant.
Dans ce cas il est fréquent \cite{Calvet2013} que la charge utile, c'est à dire le binaire d'origine, ne soit activé qu'à la dernière vague de l'exécution.
Par conséquent c'est principalement le logiciel de protection qui peut empêcher l'exécution de référence d'être représentative en détectant que le programme est instrumenté, débogué ou émulé et en détournant l'exécution dans ce cas.

\itodo{citer des cas de détection}

% \subsection{Obtention des traces et des vagues}
\subsection{Analyse statique de chaque instantané}
Pour l'analyse statique nous disposons de la trace et des instantanés munis de leurs points d'entrée et sortie respectifs.
Nous cherchons, à partir de la trace et d'un instantané, à reconstruire la vague correspondante, c'est à dire le désassemblage parfait de l'instantané.
Nous appelons trace partielle la liste des éléments de la trace qui sont exécutés au même niveau d'exécution que l'instantané étudié.
Nous utilisons la trace partielle comme guide dans l'analyse de l'instantané. Toute instruction présente dans la trace est nécessaire du code et doit être inclue dans la vague et le GFC.

\paragraph{Reconstruction du GFC par parcours récursif.}
Nous effectuons un désassemblage par parcours récursif de l'instantané à partir de chaque instruction présente dans la trace partielle.
Dans le GFC partiel reconstitué, les instructions présentes dans la trace sont en rose, les autres en blanc. Le point d'entrée et le point de sortie sont colorés en orange et bleu clair respectivement.
Si deux instructions se suivent dans la trace alors l'arc dirigé les reliant provient de l'analyse dynamique et est plein. Si elles se suivent dans l'analyse récursive alors l'arc dirigé provient de l'analyse statique et est en pointillés. Un arc étant parcouru par l'analyse dynamique et statique est en gras. Les arcs en noir relie une instruction et l'instruction séquentielle suivante tandis que les arcs en noir représentent le saut d'un appel ou d'un saut (\call\ ou \jmp\ par exemple).

\paragraph{Point de sortie.}
La dernière instruction présente dans la trace partielle constitue le point de sortie de l'instantané.
Dans le cas où cette instruction n'est exécutées qu'une seule fois dans la trace partielle, c'est à dire que le changement de niveau d'exécution intervient dès qu'elle est exécutée la première fois, nous stoppons le parcours du programme après cette instruction en considérant que les instructions suivantes doivent être analysées dans l'instantané suivant.

\paragraph{Chemins invalides.}
Si tous les chemins d'exécution passant par une instruction $D$ aboutissent nécessairement sur une instruction provoquant une erreur, soit parce que son adresse n'est pas valide, soit parce qu'elle n'est pas une adresse \xq\ valide, alors l'instruction $D$ n'est pas valide non plus.
Nous n'incluons donc par ces instructions dans le GFC.
Une instruction dont les chemins aboutissent à un saut dont les cibles ne sont pas connues ne sont pas concernées puisqu'il est possible qu'une de ces cibles soit valide.


\paragraph{Mesure du chevauchement à l'aide des \layers.}
Nous utilisons le découpage cohérent en \layers\ adapté au parcours récursif défini à la section \ref{sec:layers_decoupage_recursif} du chapitre \ref{chap:chevauchement}.
Dans le GFC deux instructions qui se chevauchent sont liées par un arc noir non dirigé tracé en pointillés.


\paragraph{Construction des blocs de base.}
Dans les exemples de GFC déjà vus précédemment, nous avons regroupé certaines instructions dans le même bloc, dit bloc de base, lorsque le regroupement aide à la lisibilité et ne fait pas perdre d'informations. Nous regrouperons deux instructions $I_1$ et $I_2$ du GFC si et seulement si :
\begin{itemize}
 \item Elles se suivent séquentiellement : elles sont reliées par un arc dirigé de $I_1$ vers $I_2$ de couleur noire, et
 \item $I_1$ n'a pas d'autres arcs sortant que celui aboutissant sur $I_2$
 \item $I_2$ n'a pas d'autres arcs entrant que celui provenant de $I_1$
 \item $I_1$ et $I_2$ ne sont pas en chevauchement avec d'autres instructions
\end{itemize}

\section{Revue de littérature}
\subsection{Architecture globale}
Une application directe de l'analyse des GFC faite dans ce chapitre est la reconstitution de l'original d'un binaire empaqueté.
Renovo \cite{renovo} et PolyUnpack \cite{polyunpack} implémentent de tels systèmes d'extraction qui fonctionnent par analyse du code généré dynamiquement, notion similaire à nos instantanés d'exécution. Ils considèrent que le binaire d'origine est celui disponible dans le dernier instantané, c'est à dire qu'ils prennent la dernière vague.


\subsection{Interprétation abstraite et analyse hybride}
Nous présentons ici des approches qui pourraient remplacer l'analyse statique simple par parcours récursif effectuée dans le cadre de ce chapitre sur les instantanés à l'aide de la trace d'exécution. Cependant elles ne sont pas aptes à remplacer l'analyse dynamique puisqu'elles sont effectuées sur des programmes non \sms.

L'analyse statique est souvent réalisée à l'aide d'une interprétation abstraite \cite{CousotC77}, méthode basée sur la définition d'une sémantique permettant d'obtenir une \sura\ des actions de chaque instructions et donc de travailler sur une \sura\ du GFC.
Kinder et Kravchenko \cite{jakstab-alternating} proposent une technique basée sur une sémantique concrète et une sémantique de \sura, alternant entre l'une et l'autre pour obtenir des résultats plus précis : il s'agit donc aussi en une sens d'une approche hybride.

Bardin, Herrmann et Védrine \cite{BHV11} proposent une méthode d'interprétation abstraite permettant de définir des niveaux de précision souhaités pour certaines variables, en particulier pour les instructions de saut dynamique. 
Une première analyse trouve des approximations grossières sur les valeurs, puis les variables dont on cherche à connaître précisément la valeur sont à nouveau analysées, jusqu'à obtenir le niveau de précision suffisant (ou échouer).
Cette approche a montré son efficacité pour déterminer les cibles de sauts dynamiques et donc pour reconstruire les GFC.


\section{Implémentation}

\section{Résultats}