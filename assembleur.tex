Cette partie est consacrée à l'analyse d'un programme utilisant des méthodes de protection.
Dans ce chapitre nous expliquons dans un premier temps ce qu'est un programme binaire et les spécificités du langage assembleur dans lequel ces programmes sont écrits.
Dans un second temps nous définissons les objectifs de l'analyse d'un programme binaire ainsi que les difficultés rencontrées.


\section{Compilation et fichiers exécutables}
% Nous nous intéressons en premier lieu aux programmes malveillants fonctionnant sur des ordinateurs personnels et en particulier aux programmes compilés, qui s'exécutent nativement dans le langage assembleur spécifique au processeur de la machine.

Un exécutable est en général d'abord écrit dans un langage de haut niveau. Chacun de ses modules est ensuite compilé en un fichier \more{objet (binaire)} encodant le langage assembleur spécifique à la machine. La dernière étape est l'édition de liens qui consiste à regrouper tous ces fichiers compilés en un exécutable unique.

Prenons l'exemple d'un simple \helloworld\ en C (Figure \ref{fig:helloword_c}). Il est uniquement composé d'un appel à la fonction \texttt{printf} permettant l'affichage, à l'exécution, de la chaîne de caractère ``Hello, world.''.
Une implémentation possible en assembleur \nasm\ \xq\ (32 bits) pouvant tourner sous une distribution GNU/Linux est donnée en figure \ref{fig:helloword_asm}. Il est alors composé de deux appels système vers le noyau Linux : un premier (sys$\_$write) permettant l'affichage de la chaîne et un second (sys$\_$exit) permettant de fermer le processus.
On peut déjà remarquer que le programme est séparé en une section de données (\pdata) contenant la chaîne de caractère à afficher et une section de code (\ptext) contenant le code assembleur à exécuter.
\begin{figure}
\begin{lstlisting}[language={C}]
int main(int argc, char* argv[]){
  printf("Hello, world.");
}
\end{lstlisting}
\caption{Code C de \helloworld}
\label{fig:helloword_c}
\end{figure}


\begin{figure}
\begin{lstlisting}[language={[x86masm]Assembler}, escapechar=~]
section .data
msg     db      "Hello, world", 0xa	; ~La chaîne à afficher~
len     equ     13                      ; ~La taille de la chaîne~

section .text
global _start

_start:
; ~Afficher la chaîne de caractères~
mov     eax, 4      ; ~Numéro d'appel système (sys$\_$write)~
mov     ebx, 1      ; ~Premier argument : le fichier de sortie (ici stdout)~
mov     ecx, msg    ; ~Second argument : un pointeur vers la chaîne à afficher~
mov	edx, len    ; ~Troisième argument : la taille de la chaîne~
int     0x80        ; ~Appel au noyau~

; ~Fermer proprement le programme~
mov     eax, 1      ; ~Numéro d'appel système (sys$\_$exit)~
mov	ebx, 0	    ; ~Premier argument : le code de retour (0 : normal)~
int     0x80	    ; ~Appel au noyau~
\end{lstlisting}
\caption{Code assembleur \xq\ (32 bits) de \helloworld}
\label{fig:helloword_asm}
\end{figure}

Le fichier binaire exécutable résultant de la compilation est un exécutable binaire pour Linux, sous format ELF.
% Le format ELF est structuré de la manière suivante. 
Comme indiqué sur la figure \ref{fig:structure_elf}, il contient des entêtes dans lesquels sont indiqués des informations générales sur le binaire telles que le point d'entrée du programme, des informations sur les différentes sections du programme (leur taille, leurs adresses) et les sections : ici une section \pdata\ (Figure \ref{fig:data_helloworld}) contient les données du programme (dont la chaîne de caractères ``Hello World'') et une section \ptext\ (Figure \ref{fig:text_helloworld}) contenant le code assembleur à exécuter. L'entête de chargement (ou \emph{program header table}) contient des informations supplémentaires pour un binaire amené à être chargé en mémoire à une adresse spécifique.
À l'instar de la figure \ref{fig:structure_elf} donnant une structure simplifiée du format ELF pour Linux, la figure \ref{fig:structure_pe} donne un aperçu du format des fichiers exécutables pour un binaire \xq\ sous Windows (format PE).

% \begin{figure}
% \begin{center}
% \subfigure[Fichier ELF]{
% \begin{tabular}[b]{|l|}
% \hline
% Entête ELF\\
% \hline
% Table des entêtes du programme\\
% \hline
% Section .text\\
% \hline
% Section .rodata\\
% \hline
% Section ...\\
% \hline
% Section .data\\
% \hline
% Table des sections\\
% \hline
% \end{tabular}
% \label{fig:structure_elf}
% }
% \subfigure[Fichier PE]{
% \begin{tabular}[b]{|l|}
% \hline
% Entête PE\\
% \hline
% Table des sections\\
% \hline
% Sections de code\\
% \hline
% Sections d'imports\\
% \hline
% Sections de données\\
% \hline
% \end{tabular}
% \label{fig:structure_pe}
% }
% \ijym{à expliquer / détailler}
% \end{center}
% \caption{Format des exécutables ELF (Linux) et PE (Windows)}
% \label{fig:structure_exe}
% \end{figure}


\begin{figure}[h]
\begin{center}
\subfigure[Fichier ELF]{
\begin{tabular}[b]{|l|}
\hline
Entête ELF\\
\hline
Entête de chargement\\
\hline
Données des sections\\
~~~~.text\\
% \hline
~~~~.rodata\\
% \hline
~~~~.data\\
% \hline
~~~~...\\
\hline
Table des sections\\
\hline
\end{tabular}
\label{fig:structure_elf}
}
\subfigure[Fichier PE]{
\begin{tabular}[b]{|l|}
\hline
Entête PE\\
\hline
Table des sections\\
\hline
Données des sections\\
~~~~de code\\
% \hline
~~~~d'imports\\
% \hline
~~~~de données\\
% \hline
~~~~...\\
~~~~\\
\hline
\end{tabular}
\label{fig:structure_pe}
}
\end{center}
\caption{Format des exécutables ELF (Linux) et PE (Windows)}
\label{fig:structure_exe}
\end{figure}


\begin{figure}[h]
\begin{center}
\begin{tabular}{|c|c|l|l|}
\hline
Emplacement & Adresses de chargement & Octets & Caractères ascii \\
dans le fichier & &  & \\
\hline
94 & 80490a4 & 48 65 6c 6c 6f 2c 20 & H e l l o ,   \\
9b & 80490ab & 77 6f 72 6x 64 & W o r l d \\
a0 & 80490b0 & 0a & Fin de chaîne       \\
\hline
\end{tabular}
\end{center}
\caption{Section \pdata\ de \helloworld}
\label{fig:data_helloworld}
\end{figure}

\begin{figure}[h]
\begin{center}
\begin{tabular}{|c|c|l|l|}
\hline
Emplacement & Adresses de chargement & Octets & Instruction\\ 
dans le fichier & &  & \\ 
\hline
80 & 8048080 & b8 04 00 00 00 & mov    eax,0x4       \\
85 & 8048085 & bb 01 00 00 00 & mov    ebx,0x1       \\
8a & 804808a & b9 a4 90 04 08 & mov    ecx,0x80490a4 \\
8f & 804808f & ba 11 00 00 00 & mov    edx,0x11      \\
94 & 8048094 & cd 80          & int    0x80          \\
96 & 8048096 & bb 00 00 00 00 & mov    ebx,0x0       \\
9b & 804809b & b8 01 00 00 00 & mov    eax,0x1       \\
a0 & 80480a0 & cd 80          & int    0x80          \\
\hline
\end{tabular}
\end{center}
\caption{Section \ptext\ de \helloworld}
\label{fig:text_helloworld}
\end{figure}


% \x64
\paragraph{Analyse de binaires.}
La principale difficulté lors de l'analyse d'un programme malveillant est que le code source n'est pas disponible à l'analyste qui doit se contenter du fichier binaire compilé.
Un programme compilé se présente donc sous la forme d'un fichier binaire contenant le code machine devant être lancé à l'exécution du programme ainsi que des informations de chargement du binaire : la distinction de différentes sections, les adresses mémoires auxquelles le système devra les charger en mémoire, ainsi que les bibliothèques logicielles du système dont il a besoin et qui devront être chargées en mémoire à l'exécution.

La principale tâche de l'analyste est alors d'extraire du fichier binaire les informations utiles et surtout d'analyser les parties de code assembleur de l'exécutable. Nous détaillerons, dans la suite de ce chapitre, quelques spécificités du langage assembleur considéré et les difficultés rencontrées par l'analyste.

\label{section:assembleur}
\section{Assembleur \xq\ et \xs}
L'architecture la plus fréquente pour les processeurs des ordinateurs personnels est celle des processeurs Intel CISC avec le jeu d'instructions \xq\ pour les machines adressant la mémoire sur 32 bits, et le jeu d'instructions \xs\ pour celles adressant la mémoire sur 64 bits.

Nous allons présenter deux approches historiques pour l'architecture d'une machine et expliquerons quelles notions de ces deux architectures sont présentes dans les processeurs actuels.

\paragraph{Architecture de Harvard et de von Neumann.}
L'architecture de Harvard \cite{ibm_mark1}, sépare le code exécutable des données en deux mémoires distinctes.
La première implémentation de l'architecture de Harvard était L’ASCC (Automatic Sequence Controlled Calculator) d'IBM, également appelé le Mark I et considérée comme le premier calculateur universel, en 1944. 
Il lisait les instructions sur des cartes perforées et les données étaient entrées manuellement à l'aide d'interrupteurs. 
Ainsi le code exécutable était physiquement non modifiable et séparé des données. 

% \paragraph{Architecture de Von Neumann.}
L'architecture de von Neumann, nommée en référence aux travaux de John von Neumann, John William Mauchly et John Eckert en 1945, acceptait la modification de la logique des programmes \cite{timsit}.
Elle était cependant limitée à l'utilisation d'un seul bus de données entre le processeur et la mémoire.
Cette restriction limitait grandement les capacités de lecture et d'écriture mémoire d'une machine utilisant le modèle de von Neumann.

% \paragraph{Architecture actuelle.}
L'architecture utilisée actuellement pour les ordinateurs personnels est un mélange des deux approches.
Elle utilise plusieurs bus mémoire mais les instructions et les données sont stockées dans la même mémoire et donc accessibles autant en lecture qu'en écriture \cite{timsit}.
Dans ce modèle la machine est articulée autour du processeur et de son unité de contrôle chargée de synchroniser les autres composants, d'exécuter les instructions du binaire chargé en mémoire, de gérer les entrées et les sorties, de lire et d'écrire dans la mémoire et les registres.
Les registres ne peuvent contenir que des entiers dans les intervalles $\textlbrackdbl -2^{31},\ 2^{31}-1\textrbrackdbl$ ou  $\textlbrackdbl -2^{63},\ 2^{63}-1\textrbrackdbl$ en assembleur \xq\ et \xs\ respectivement.
L'unité arithmétique et logique opère toute l'arithmétique du processeur et modifie les drapeaux du registre d'état en conséquence selon les résultats des opérations effectuées. 
% Par exemple une addition provoque un débordement d'entier lorsque le résultat de l'addition ne peut être stocké dans un seul registre :  dans ce cas le drapeau de dépassement d'entier (OF) est passé à 1.
Une organisation simplifiée d'une machine utilisant ce modèle est donnée Figure \ref{fig:arch_harvard_mod}.

\begin{figure}[h]
\begin{center}
\scalebox{1}{
\begin{tikzpicture}[->,scale=1,>=stealth',thick]
\node[state] (UC){Unité de contrôle};
\node[state, above=2cm of UC] (MEM){Mémoire};
\node[state, above right=0.5cm and 3cm of UC.east] (REG){Registres};
\node[state, below right=1cm and -1cm of REG.south west] (UAL){Unité arithmétique et logique};
\node[state, below=2cm of UC.south] (INPUT){Entrées et sorties};

\path[->] ($(MEM.south) + (-0.2, 0) $)  edge   [bend right=10]  ($(UC.north) + (-0.2, 0) $);
\path[->] ($(UC.north) + (0.2, 0) $)  edge   [bend right=10]  ($(MEM.south) + (0.2, 0) $);
\path[->] ($(INPUT.north) + (-0.2, 0) $)  edge   [bend left=10]  ($(UC.south) + (-0.2, 0) $);
\path[->] ($(UC.south) + (0.2, 0) $)  edge   [bend left=10]  ($(INPUT.north) + (0.2, 0) $);

\path[->] ($(REG.west) + (0, 0) $)  edge   [bend right=10]  ($(UC.north east) + (0, 0) $);
\path[->] ($(UC.north east) + (0, -0.1) $)  edge   [bend right=10]  ($(REG.west) + (0, -0.1) $);
\path[->] ($(UAL.west) + (0, 0) $)  edge   [bend left=10]  ($(UC.south east) + (0, 0) $);
\path[->] ($(UC.south east) + (0, +0.1) $)  edge   [bend left=10]  ($(UAL.west) + (0, +0.1) $);

\path[->] ($(UAL.north) + (-0.7cm, 0) $)  edge   [bend right=10]  ($(REG.south) + (0, 0) $);

\node [fit={($(UC.west) + (0, 0)$) ($(REG.north east) + (0, 0)$) ($(UAL.south east) + (0, 0.0)$)}, draw, label=\large Processeur] {};
\end{tikzpicture}
}
\end{center}
\caption{Architecture simplifiée}
\label{fig:arch_harvard_mod}
\end{figure}

\paragraph{Structure de la mémoire.}
La mémoire physique de la machine peut-être faite, entre autres, de mémoire volatile (mémoire vive) et de supports amovibles (disques durs).
Chacun de ces supports peut être vu comme une liste d'adresses mémoire où l'on peut stocker des données et le système d'exploitation gère ces supports comme il l'entend.
Plus précisément un programme n'est pas nécessairement chargé sur une plage contiguë d'adresses mémoire.
Pour éviter au programmeur de devoir gérer des adresses mémoires qui ne concernent pas son programme, un mécanisme de mémoire virtuelle est mis en place : de son point de vue, le programme courant voit sa mémoire comme un intervalle d'adresses mémoire contiguës. C'est le système d'exploitation qui traduit les adresses virtuelles en adresses physiques lors de l'exécution du programme.
Cette technique permet au système d'exploitation de choisir, de manière transparente pour le programme, un support différent pour certaines parties du programme. Elle lui permet aussi de gérer plus finement l'accès à la mémoire, tant pour interdire l'accès à certaines zones que pour partager des zones entre plusieurs processus.

En pratique, lors de l'exécution d'un programme, des informations peuvent être stockées en plusieurs lieux. 
Tout d'abord les registres du processeur permettent un accès rapide à quelques variables.
Certains registres sont réservés, souvent par convention. Par exemple, lors d'un appel de fonction, la convention par défaut (CDECL) stipule que la valeur de retour est passée dans le registre \texttt{eax}.
La seconde structure de mémoire est la pile. 
Il s'agit d'une structure de type LIFO (\emph{Last In First Out}) dans laquelle les mots (de 32 bits en \xq, 64 en \xs) sont empilés à l'aide de l'instruction \texttt{push} et dépilés avec l'instruction \texttt{pull} de sorte que le mot dépilé est celui qui a été empilé en dernier.
Les variables locales sont en général enregistrées sur la pile et, lors d'un appel de fonction, les arguments sont passés sur la pile.
La dernière structure est le tas qui est géré par l'appel de fonctions d'allocations dynamiques (telles \texttt{malloc} en C) et est généralement utilisé pour entreposer les structures mémoire plus encombrantes telles que des tableaux ou des structures complexes.
En pratique la mémoire d'un processus contient d'abord les sections de code, puis les sections de données, puis le tas qui est susceptible de s'étendre ainsi que la pile qui peut également s'étendre, dans le sens inverse (Figure \ref{fig:mem_process}).

\begin{figure}[h]
\begin{center}
\scalebox{1}{
\begin{tikzpicture}[->,scale=1,>=stealth',thick]
\node[state, draw=none] (ADR1){\small Adresses mémoire basses};
\node[state, draw=none, below=6cm of ADR1.south] (ADR2){\small Adresses mémoire hautes};
\node[state, rectangle split, rectangle split parts=3, below right=0.7cm and -1cm of ADR1.east, draw, label=, text width=5cm] (MEM){Code \nodepart{second} Données \nodepart{third} Tas \\ ~\\ ~\\ ~\\ ~\\ ~\\ ~\\ Pile};
\draw (ADR1.south) -> node[right=.2cm]{} (ADR2.north);
\draw ($(MEM.north) + (0, -1.9) $) -> node[right=.2cm]{} ($(MEM.north) + (0, -2.9) $);
\draw ($(MEM.south) + (0, +0.7) $) -> node[right=.2cm]{} ($(MEM.south) + (0, +1.7) $);
\end{tikzpicture}
}
\end{center}
\caption{Organisation de la mémoire d'un processus}
\label{fig:mem_process}
\end{figure}



\paragraph{Jeu d'instructions.}
Les processeurs Intel \xq\ utilisent un jeu d'instruction complexe (CISC). La représentation d'une instruction en une suite d'octets inclut principalement un code d'opération (ou \emph{opcode}) et ses arguments. Des informations supplémentaire peuvent être codées dans l'instruction, comme des préfixes. Le format détaillé des instructions est donné à la figure \ref{fig:format_insts_x86}.
L'instruction \texttt{mov ecx, 0x080490a4} du programme précédent, codée sur les octets \texttt{b9 a4 90 04 08} est composée du code d'opération \texttt{b8+r} indiquant une opération de copie d'une valeur immédiate vers un registre. Ici r est égal à 1, ce qui indique que le registre concerné est \ecx. La valeur à copier vers le registre est \texttt{0x080490a4} soit les octets \texttt{a4 90 04 08} codés en petit-boutistes (\emph{little endianness}), c'est à dire que les mots de poids faible sont écrits en premier, à l'inverse de l'écriture usuelle.
% Il s'agit d'une assignation immédiate et la valeur à copier vers \texttt{ecx} est la valeur immédiate.
Le décalage permet de modifier une instruction d'adressage indirect comme \texttt{mov ecx, [eax]}, écrivant le contenu en mémoire à l'adresse \texttt{eax} dans le registre \texttt{ecx} en \texttt{mov ebx, [eax+d]} où \texttt{d} est le décalage.
Enfin les préfixes permettent par exemple de répéter plusieurs fois l'instruction jusqu'à ce qu'une condition sur un registre soit remplie.

\begin{figure}[h]
\begin{center} 
\begin{tabular}{l|l|l|l|l|l|}
\cline{2-6}
% Prefixe & Opcode & Modificateur & SIB & Déplacement d'octet & Adressage\\
% 1 à 4 & 1 à 3 & 0 ou 1 & 0 ou 1 & 0 à 4 & 0 à 4\\
& Préfixe & Opcode & Modificateur & Décalage & Valeur immédiate \\
& 1 à 4 & 1 à 3 & 0 à 2 & 0 à 4 & 0 à 4\\
\cline{2-6}
\multicolumn{1}{l}{Exemples :} & \multicolumn{5}{l}{}\\
\hline
\multicolumn{1}{|l|}{mov ecx, 0x080490a4} & & b9 & & & a4 90 04 08 \\
\multicolumn{1}{|l|}{add eax, 2} & & 83 & c0 & & 02 \\
\hline
\end{tabular}
\end{center} 
\caption{Format d'une instruction \xq\ et taille des opérandes en octets}
\label{fig:format_insts_x86}
\end{figure}

\paragraph{Intuition de sémantique.}
Bien que la documentation exhaustive d'Intel pour les processeurs \xq\ et \xs\ \cite{intel_vol2} détaille plusieurs centaines d'instructions, elles peuvent être regroupées en 3 classes informelles.
Prenons l'instruction \texttt{mov} : elle sert à copier des informations depuis une zone (mémoire ou registre) vers une autre zone.
Ainsi \texttt{mov eax, [ebx+10]} copie la valeur à l'adresse \texttt{ebx+10} dans le registre \eax. 
Cette instruction est déclinée en plusieurs dizaines de variantes selon la taille et le type des opérandes copiés.

Une seconde catégorie d'instructions permet de gérer les opérations arithmétiques sur les octets en mémoire et dans les registres.
Une instructions comme \texttt{add eax, ebx} ajoute la valeur de \ebx\ à celle de \eax\ et stocke le résultat de l'opération dans \eax.
Ce type d'opération combine en fait une opération arithmétique et une assignation. 
On peut y inclure l'instruction \cmp\ qui compare deux valeurs et met à jour les drapeaux de tests. 
Ces drapeaux indiquent entre autres le signe du résultat d'une opération ainsi que si elle a provoqué un débordement d'entier.
% En fait les instructions arithmétiques comme \add\ provoquent aussi une mise à jour de ces drapeaux : il s'agit d'une assignation implicite.\jym{sens ? expliquer ce qu'on veut dire par explicite/implicite?}
\imore{assignations implicites et explicites?}

Les instructions précédemment décrites sont séquentielles et ne modifient pas l'ordre d'exécution des instructions. 
Après l'exécution d'une instruction de type \mov\ à l'adresse $a$ codée sur $n$ octets, l'instruction située à l'adresse $a+n$ sera exécutée.
Le dernier type d'instruction modifie le flot de contrôle du programme : elles effectuent des sauts à des adresses spécifiées dans le programme.
Ces sauts peuvent être inconditionnels comme un \texttt{jmp 8048085} qui provoque un saut à l'adresse \adr{8048085} ou le saut dynamique \texttt{jmp eax} dont l'adresse cible du saut est la valeur de \eax.
Les sauts peuvent aussi être conditionnels : l'instruction \texttt{je~+10}, à l'adresse $a$ et de taille $n$, sera suivie de l'instruction à l'adresse $a+10$ si le registre ZF vaut 1 et de l'instruction à l'adresse $a+n$ dans le cas contraire.

\imore{parler du multi-threading, de cores et de l'accès mémoire en cas de multi-threading}


\section{Désassemblage}
Analyser un programme sous forme binaire est en général plus difficile que d'analyser le code source du programme écrit dans un langage de haut niveau.
La compilation provoque une perte d'informations de haut niveau.
Par exemple en assembleur il n'y a plus de noms ni de types pour les variables et les fonctions. 

Le désassemblage est l'opération inverse de l'assemblage : il consiste à récupérer le code assembleur source du binaire.
Cette tâche semble particulièrement simple puisque l'assemblage consiste à trouver les octets correspondants à chaque instruction à l'aide de la documentation officielle du processeur puis à mettre en forme le fichier binaire en remplissant correctement ses entêtes et ses sections.
Pourtant on a vu que, dans le modèle de von Neumann, les données et le code peuvent être mêlés. 
En particulier les parties de données (comme la section \pdata) peuvent être exécutées. 
De même les sections de code peuvent contenir des informations destinées à être simplement lues ou modifiées mais jamais exécutées.
La difficulté du désassemblage consiste donc à séparer les parties potentiellement exécutables des données.

Ainsi un désassemblage a priori cohérent de \helloworld\ consisterait à considérer les deux sections comme contenant du code potentiellement exécutable. Ce désassemblage sera composé de la section \ptext\ d'origine (figure \ref{fig:text_helloworld}) et de la section \pdata\ (figure \ref{fig:data_exec_helloworld}).

\begin{figure}[h]
\begin{center}
\begin{tabular}{|c|c|l|l|}
\hline
Emplacement & Adresses de chargement & Octets & Instruction\\ 
dans le fichier & &  & \\ 
\hline
94 & 80490a4 & 48    & dec    eax			\\
95 & 80490a5 & 65    & gs				\\
96 & 80490a6 & 6c    & ins    BYTE PTR es:[edi],dx	\\
97 & 80490a7 & 6c    & ins    BYTE PTR es:[edi],dx	\\
98 & 80490a8 & 6f    & outs   dx,DWORD PTR ds:[esi]	\\
99 & 80490a9 & 2c 20 & sub    al,0x20			\\
9b & 80490ab & 77 6f & ja     0x804911c			\\
9d & 80490ad & 72 6c & jb     0x804911b			\\
9f & 80490af & 64    & fs				\\
a0 & 80490b0 & 0a    & .byte 0xa			\\
\hline
\end{tabular}
\end{center}
\caption{Section \pdata\ de \helloworld\ désassemblée comme du code}
\label{fig:data_exec_helloworld}
\end{figure}

Ce désassemblage n'est pas correct et on peut le prédire. 
On connaît le point d'entrée du binaire, qui est l'adresse \texttt{8048080} dans la section \ptext.
Les instructions exécutées dans la section \ptext\ à la suite du point d'entrée sont séquentielles et ne peuvent détourner l'exécution vers la section \pdata. 
Le code désassemblé dans cette section n'est donc pas atteignable. Dans ce cas on sait alors que la section \pdata\ ne contient pas de code et ne doit pas être désassemblée.



% \paragraph{Utilisation de sauts dynamiques.}
En pratique un programme est constitué d'un grand nombre d'instructions de saut et notamment de sauts dynamiques de type \texttt{jmp eax}.
Ce type d'instructions pose un souci lors de l'analyse : sans connaître précisément la ou les valeurs potentielles d'\eax, il est impossible de prédire la cible du saut et donc de savoir le code potentiellement exécuté à la suite de cette instruction.
Dans l'exemple du \helloworld, si une telle instruction est présente dans la section \ptext, il devient difficile d'exclure l'exécution possible de code dans la section \pdata.
Une des principales difficultés lors du désassemblage réside dans la présence de ces sauts dynamiques dont la cible ne peut être déterminée qu'en ayant une connaissance fine de la ou des valeurs possibles des différents registres.
\\

Dans cette partie nous nous intéressons au problème du désassemblage, tant d'un point de vue théorique en définissant ses objectifs et les obstacles rencontrés, que d'un point de vue pratique en expliquant les différentes techniques mises en \oe uvre pour l'effectuer.

Nous utilisons les notions expliquées précédemment et l'architecture simplifiée que nous avons décrite, dans laquelle les instructions et les données ne sont pas séparées dans la mémoire.
Certains programmes, dits \sms, utilisent ce fait pour modifier leur code au fur et à mesure de leur exécution, rendant leur analyse plus difficile. Un des objets de cette thèse est l'étude de ces programmes : nous détaillerons dans les chapitres suivants leur fonctionnement et certaines techniques d'analyse.

Cependant, dans la suite de ce chapitre introductif, nous considérons que les programmes étudiés ne sont pas \sms. 
Cela nous permet de définir les notions de désassemblage et de graphe de flot de contrôle dans un cas plus simple tandis que nous étendrons ces définitions dans les chapitres suivants.
En conséquence, dans ce chapitre, l'intégralité du code des programmes est observable dès leur chargement en mémoire et ce code n'est pas amené à être modifié au cours de l'exécution.

\subsection{Reconstruction du graphe de flot de contrôle}
Nous avons utilisé jusqu'ici une représentation des programmes assembleur et binaires sous forme de code linéaire mais il est plus aisé de visualiser les programmes à l'aide d'un graphe de flot de contrôle (GFC).
Ce graphe représente les instructions sous forme de sommets et les sauts du flot de contrôle d'une instruction à une autre sous forme d'arcs.
Prenons le programme assembleur donné en figure \ref{fig:asm_eax_code}. Il ne fait que modifier le registre \eax, effectue des sauts selon la valeur d'\eax\ et se termine avec une valeur pour \eax\ à 1 ou 2. L'instruction \texttt{mov eax, 3} n'est pas atteignable puisqu'elle suit un saut inconditionnel et qu'aucune autre instruction ne provoque un saut vers elle.
Ainsi le graphe de flot de contrôle de ce programme est celui donné en figure \ref{fig:asm_eax_cfg}.

% Un graphe de flot parfait inclut exactement l'ensemble des instructions atteignables dans le programme et un arc ne relie deux instructions que s'il existe au moins une exécution du programme dans laquelle les deux instructions sont exécutées consécutivement.

\begin{figure}[h]
\begin{center}
\subfigure[Code assembleur]{
\begin{tabular}[b]{|l|l|l|}
\hline
Adresse & Octets & Instruction\\ 
\hline
 8048067  &  b8 00 00 00 00         &  mov    eax,0x0 \\
 804806c  &  eb 05                  &  jmp    0x8048073 \\
 804806e  &  b8 03 00 00 00         &  mov    eax,0x3 \\
 8048073  &  83 f8 00               &  cmp    eax,0x0 \\
 8048076  &  74 06                  &  je     0x804807e \\
 8048078  &  b8 01 00 00 00         &  mov    eax,0x1 \\
 804807d  &  c3                     &  ret     \\
 804807e  &  b8 02 00 00 00         &  mov    eax,0x2 \\
 8048083  &  c3                     &  ret     \\
\hline
\end{tabular}
\label{fig:asm_eax_code}
}
\subfigure[Graphe de flot de contrôle]{
\includegraphics[width=0.43\textwidth]{supports/eax-cfg/eax2_cropped0.pdf}
% \input{supports/eax-cfg/eax.tex}
\label{fig:asm_eax_cfg}
}
\end{center}
\caption{Représentation d'une fonction assembleur modifiant \eax}
\label{fig:asm_eax}
\end{figure}

Le sommet coloré en orange est le point d'entrée du programme. Dans le cas où le flot de contrôle peut passer de l'instruction $a$ à l'instruction $b$, l'arc entre $a$ et $b$ est en noir si $b$ suit $a$ en mémoire et en rouge dans le cas contraire, c'est à dire s'il s'agit d'un saut.

\FloatBarrier
\subsection{Parcours linéaire}
Un désassemblage suivant un parcours linéaire désassemble, pour chaque section, la première instruction à l'adresse $a$ puis l'instruction à l'adresse $a+k$ où $k$ est le nombre d'octets sur lesquels l'instruction est codée.
Ainsi pour une suite d'instructions séquentielles cette méthode suit le flot de contrôle mais si une instruction de type \jmp\ est rencontrée, le désassemblage s'intéressera à l'instruction qui suit en mémoire et non celle qui sera logiquement exécutée ensuite.
La figure \ref{fig:asm_eax_code}, donnée précédemment, est un exemple de désassemblage linéaire d'une fonction assembleur.

L'algorithme \ref{algo:parcours_lineaire} explicite le parcours linéaire d'un programme composé de plusieurs sections étant chacune un bloc d'octets présent à une adresse mémoire.
Un désassemblage consiste en la donnée d'un ensemble de couples dont chaque couple représente une instruction assembleur : le premier élément du couple est l'adresse où l'instruction est présente et le second élément est l'instruction \xq\ ou \xs\ étant à cette adresse.
Nous désassemblons entre la première et la dernière adresse mémoire de chaque section et supposons que l'on dispose de deux opérateurs supplémentaires $decode$ et $taille$.
Le premier fournit, à partir d'une adresse et d'un programme, l'instruction présente à cette adresse dans le programme.
Le second indique la taille d'une instruction, c'est à dire le nombre d'octets sur lesquels elle est codée.

\begin{algorithm}[H]
\caption{Désassemblage linéaire d'un programme P composé de plusieurs sections}
\SetAlgoLined
\KwIn{Un programme P composé de plusieurs sections}
\KwResult{Le désassemblage linéaire de P}
\SetKwProg{Fn}{}{}{}
\SetKwFunction{FRecurs}{desassemblageLineaire}
\Fn(
){\FRecurs{P}}{
$D \leftarrow\ \emptyset$\\
\For {toute section S de P}{
\tcp*[h]{On désassemble section par section}\\
  $D \leftarrow\ D\cup desassemblageSection(S, P)$\\
}
\Return $D$
}
~\\
\SetKwFunction{FRecurs}{desassemblageSection}
\Fn(
){\FRecurs{S, P}}{
  \tcp*[h]{On va désassembler entre la première et la dernière adresse mémoire où S est mappée}\\
  $debut \leftarrow premiereAdresse(S)$  \\
  $fin \leftarrow derniereAdresse(S)$    \\
  $a \leftarrow debut$ \\
  $D \leftarrow\ \emptyset$\\
  \While{$a\leq fin$}{
    \tcp*[h]{On récupère l'instruction de P présente à l'adresse a}\\
    $I\leftarrow decode(a, P)$ \\
    $D\leftarrow D\cup \{(a, I)\}$ \\
    $a\leftarrow a+taille(I)$
  }
  \Return $D$
}
\label{algo:parcours_lineaire}
\end{algorithm}

L'avantage de cette technique réside dans sa simplicité et le fait qu'elle couvre l'ensemble de la mémoire.
Pourtant, ne cherchant pas à suivre le flot de contrôle, elle ne permet pas de séparer le code exécutable des données et désassemble des instructions qui ne sont pas atteignables comme l'instruction \mov\ à l'adresse $804806e$ de la figure \ref{fig:asm_eax_code}.
C'est l'approche utilisée par le désassembleur standard du projet GNU, objdump \cite{objdump}.
La commande de désassemblage par défaut du désassembleur interactif libre Radare \cite{radare} fonctionne également par parcours linéaire.



\subsection{Parcours récursif}
À l'inverse du parcours linéaire, le parcours récursif suit le flot de contrôle et désassemble les instructions qui se suivent logiquement en partant du point d'entrée du programme. Le graphe de flot de contrôle peut être déduit du parcours récursif : la figure \ref{fig:asm_eax_cfg} donne celui de l'exemple précédent.

L'algorithme \ref{algo:parcours_recursif} détaille le parcours récursif d'un programme ayant un point d'entrée.
Nous avons cette fois besoin de connaître les enchaînements possibles à la suite de l'exécution d'une instruction : nous ajoutons alors l'opérateur $fils$ qui, à partir d'une instruction $I$, renvoie l'ensemble des adresses des instructions pouvant être exécutées à la suite de $I$.
Une instruction de saut conditionnel aura typiquement deux fils : le premier est atteint si la condition est remplie et on atteint le second dans le cas contraire.

\begin{algorithm}[H] %or another one check
\caption{Désassemblage récursif d'un programme P}
\SetAlgoLined
\KwIn{Un programme P de point d'entrée $ep$}
\KwResult{Le désassemblage récursif de P}
\SetKwProg{Fn}{}{}{}
\SetKwFunction{FRecurs}{desassemblageRecursif}
\Fn(
){\FRecurs{P}}{
\tcp*[h]{On désassemble à partir du point d'entrée de P}\\
\Return $desassemblage(ep, \emptyset, P)$
}
~\\
\SetKwFunction{FRecurs}{desassemblage}
\Fn(
){\FRecurs{a, D, P}}{
  $I\leftarrow decode(a, P)$ \\
  $D\leftarrow D\cup \{(a, I)\}$ \\
  \tcp*[h]{On désassemble récursivement tous les fils de I qui n'ont pas déjà été parcourus}\\
  \For {$a'\in fils(I)$}
  {
  \If {$a'$ n'est pas présent dans D}{
    $D\leftarrow D\cup desassemblage(a', D, P)$ \\
  }
  }
  \Return $D$
}
\label{algo:parcours_recursif}
\end{algorithm}

L'avantage de cette technique est qu'elle ne désassemble que des instructions dont on peut raisonnablement penser qu'elles sont atteignables.
Cependant certains chemins ne sont pas atteignables en raison de variables définies. 
L'instruction à l'adresse \texttt{8048076} provoque un saut vers l'adresse \texttt{804807e} si la comparaison effectuée à l'instruction précédente est vraie, c'est à dire si $\eax=0$, et saute vers l'adresse \texttt{8048078} dans le cas contraire.
Or la première instruction de la fonction donne à \eax\ la valeur 0. Dans tous les cas le saut se produira donc vers l'adresse \texttt{804807e} et l'autre branche n'est pas atteignable.

D'autre part si des sauts dynamiques sont utilisés comme avec l'instruction \texttt{jmp eax}, le parcours récursif s'arrête alors qu'il est clair que d'autres instructions seront exécutées.
La difficulté théorique vient du fait que déterminer l'ensemble des valeurs possibles pour \eax\ est dans certains cas un problème indécidable.
Le désassembleur commercial IDA~\cite{IDA} fonctionne par parcours récursif.
% \jym{déterminer eax peut être indécidable // le pb vient des embranchements et des prédicats opaques ?}


% \section{Désassemblage}
% Nous avons vu que le problème du désassemblage tient dans la difficulté à séparer les parties de codes des parties de données d'un programme binaire.


% Dans cette partie nous proposons une formalisation du problème du désassemblage et une preuve de son caractère indécidable puis nous décrirons brièvement les deux approches du problème que sont l'analyse statique et l'analyse dynamique.

\subsection{Désassemblage parfait et graphe de flot de contrôle parfait}
Il est aisé de définir ce que l'on appelle code lors d'un désassemblage : il s'agit de toute partie du programme sur laquelle est écrite une instruction atteignable lors d'une exécution du programme.
Les données sont les parties du programme qui peuvent être lues lors d'une exécution du programme. 
Une partie du programme peut être à la fois lue et exécutée et donc être à la fois de la donnée et du code.
Une adresse d'un binaire chargé en mémoire peut donc être soit inutilisée, soit atteignable lors de l'exécution, soit potentiellement lue, soit potentiellement lue et exécutée.

% \setlength{\parskip}{5mm}
\begin{center}
\begin{tikzpicture}
% Definition of circles
\def\firstcircle{(0,0) circle (1cm)}
\def\secondcircle{(0,-1.5cm) circle (1cm)}
\def\thirdcircle{(0,-0.75cm) circle (2cm)}

\colorlet{circle edge}{black!100}
\colorlet{circle area}{black!20}

\tikzset{filled/.style={fill=circle area, draw=circle edge, thick},
    outline/.style={draw=circle edge, thick}}
    \begin{scope}
        \clip \firstcircle;
        \fill[filled] \secondcircle;
    \end{scope}
    \draw[outline] \firstcircle node {Code};
    \draw[outline] \secondcircle node {Données};
    \draw[outline] \thirdcircle node {};
    \node[anchor=south] at (current bounding box.north) {Programme};
\end{tikzpicture}
\end{center}

Une définition formelle du désassemblage parfait d'un programme P (définition \ref{def:desassemblage_parfait_nsm}) est alors la détermination de l'ensemble des instructions atteignables de P, munies de l'adresse à laquelle elles sont présentes dans P.
Nous utilisons, comme précédemment, l'opérateur $decode$ qui, à partir d'une adresse et d'un programme, renvoie l'instruction présente à cette adresse dans le programme.

\begin{defi}
 Étant donné un programme P \nsm\ prenant une entrée I, le désassemblage parfait de P est la donnée de $\bigcup_{I} \{(a, decode(a, P)),\ P(I)\ atteint\ a\}$.
\label{def:desassemblage_parfait_nsm}
\end{defi}

L'analyste est intéressé par davantage d'informations que la seule liste des instructions atteignables.
L'enchaînement des instructions lors des différentes exécutions du programme est une donnée primordiale.
Reprenons l'exemple de code assembleur de la figure \ref{fig:asm_eax_code}. Une exécution possible consiste à prendre les instructions \adr{8048067}, \adr{804806c}, \adr{8048073}, \adr{8048076}, \adr{804807e}, \adr{8048083} dans cet ordre. En fait quelles que soient les valeurs initiales de \eax, des autres registres ou de la mémoire, le chemin précédent est toujours emprunté : il s'agit du seul chemin d'exécution possible.
% Il est utile de connaître les enchaînements d'instructions possibles, représentés dans le graphe de flot de contrôle.
La meilleure source pour l'analyse d'un programme serait cette connaissance de tous les chemins d'exécution possibles, quelle que soit l'entrée donnée au programme (définition \ref{def:exec_possibles}).

\begin{defi}
 Étant donné un programme P prenant une entrée I, l'ensemble des chemins d'exécution possibles de P est l'union sur les entrées I des chemins d'exécution pris par P(I).
\label{def:exec_possibles}
\end{defi}

À partir de cette donnée il est possible de parcourir l'ensemble des comportements possibles du programme, que ce soit la valeur des différents registres au cours de l'exécution, les interactions entre le programme et le système d'exploitation ou les enchaînements possibles entre différentes instructions.
Nous nous intéressons en particulier au graphe de flot de contrôle parfait (définition \ref{def:cfg_parfait_nsm}) dans lequel les sommets seraient exactement les adresses de toutes les instructions atteignables et un arc relierait deux instructions si et seulement si il existe un chemin d'exécution dans lequel les deux instructions se suivent immédiatement.
% Cette définition d'un graphe de flot de contrôle parfait représente une instruction par son adresse en mémoire : il s'agit d'une simplification cohérente dans le cas d'un programme \nsm\ et 
Nous ne nous intéressons ici qu'aux programmes \nsms\ mais nous verrons par la suite comment étendre la notion de graphe de flot de contrôle parfait à un programme qui se modifie lui-même.

\begin{defi}
 Étant donné un programme \nsm\ P prenant une entrée I, le graphe de flot de contrôle parfait de P est le graphe orienté $T=(V, E)$ tel que :
 \begin{itemize}
  \item L'ensemble V des sommets de T est l'ensemble de couples (adresse, instruction) présents dans le désassemblage parfait de T
  \item $E\subset V\times V$ est l'ensemble des arcs de T
  \item $(a, b)\in E$ si et seulement si il existe un chemin d'exécution de P au sein duquel l'adresse $b$ suit immédiatement l'adresse $a$ dans l'ordre d'exécution.
 \end{itemize}
\label{def:cfg_parfait_nsm}
\end{defi}

En pratique nous ne disposons pas de la liste exhaustive de tous les chemins d'exécution possibles du programme à analyser. Notre objectif est alors d'obtenir une approximation cohérente du graphe de flot de contrôle parfait. 
% C'est à cette fin que nous décrivons et développons différentes techniques d'analyses dans les prochains chapitres.



\subsection{Difficulté théorique du désassemblage}
\idone{Pb de l'arrêt: il existe HALT / pour tout P,I : HALT(P,I) = 1 ssi P(I) termine}
\imore{Pb du désassemblage : borne min : intersection de CODE(P,I), borne max : union}
\imore{borne min ~ arrêt ?}
% On a vu que le problème du désassemblage tient dans la difficulté de séparer les parties de code potentiel des parties de données.
Si on cherche à séparer le code des données alors le but du désassemblage d'un programme P est de résoudre le problème suivant. On se limite dans un premier temps à un programme P non auto-modifiant.
\begin{pb*}
Soit \adr{a} une adresse, existe-t-il une entrée I de P telle que P(I) atteint \adr{a} ?
\end{pb*}

Nous reprenons ici un argument tiré de la thèse de Joan Calvet \cite{Calvet2013} montrant le caractère indécidable de ce problème en réduisant le problème de l'arrêt à celui-ci.

% Supposons que le problème soit décidable. 
Notons CODE le programme vérifiant, pour tout programme P et adresse \adr{a}, CODE(P, \adr{a}) = 1 si et seulement si il existe une entrée I de P telle que P(I) atteint \adr{a}. Dans le cas contraire CODE (P, \adr{a}) = 0.

Soit P un programme ne prenant pas d'entrée et ayant un unique point d'arrêt indiqué par l'instruction \halt\ à l'adresse $\alpha$.
CODE(P, $\alpha$) = 1 si et seulement si P atteint l'adresse $\alpha$, c'est à dire si et seulement si P termine.

On en déduit donc que le désassemblage permet de résoudre le problème de l'arrêt qui est pourtant connu pour être indécidable ; c'est absurde.
Ainsi le problème du désassemblage d'un programme \nsm\ est indécidable.
Le désassemblage d'un programme \sm\ est un cas plus difficile que celui traité ici : il s'agit également un problème indécidable.


\subsection{Analyse statique et dynamique}
Dans le domaine de l'analyse de code, on parle d'analyse dynamique lorsque le fichier binaire à analyser est exécuté au moins partiellement et que l'analyse consiste à observer une ou des exécutions du programme. Au contraire lors d'une analyse statique on cherche à inférer les propriétés du programme sans l'exécuter.

Les deux techniques permettent de récupérer du code assembleur à partir du programme et donc de réaliser un désassemblage et de reconstruire un graphe de flot de contrôle.
L'avantage de l'analyseur dynamique est que, puisqu'il travaille sur une exécution spécifique du programme, il est précis : les instructions qui sont exécutées doivent être inclues dans le désassemblage.
Les traces d'exécution fournissent ainsi une \sousa\ de l'ensemble des chemins d'exécution possibles.
Par contre l'analyseur dynamique n'est pas complet vu qu'il ne suivra pas des branches du programme qui pourraient être utilisées si leurs conditions étaient vérifiées. À l'inverse un analyseur statique n'est pas précis et ne peut en général pas être complet à cause de l'impossibilité de prédire certaines cibles de sauts dynamiques. En considérant que les sauts dynamiques dont les cibles sont inconnues peuvent aboutir à n'importe quelle adresse mémoire, l'analyse statique fournit une \sura\ de l'ensemble des chemins d'exécution possibles.

En pratique le désassemblage est classiquement du domaine de l'analyse statique. Nous expliquerons comment l'analyse dynamique peut aider à reconstruire les graphes de flot et le code des programmes obscurcis.

% \section{Difficulté calculatoire de l'analyse de binaire}
% \subsection{Désassemblage}
% \subsection{Décompilation}

\section*{Conclusion}
\imore{Expliquer quelques différences entre \xq\ et \xs}
Nous avons décrit les machines sur lesquelles les programmes que nous étudions s'exécutent : il s'agit des ordinateurs avec une architecture \xq\ ou \xs.
Un programme assembleur est généralement initialement écrit dans un langage de haut niveau puis compilé en un binaire encodant les instructions dans le langage assembleur cible.

Le principal problème du désassemblage réside dans la difficulté de séparer le code exécutable des données dans un fichier binaire : cette séparation est un problème indécidable.
Le chapitre suivant présente plusieurs méthodes d'obscurcissement de code utilisées par les auteurs de logiciels malveillants pour compliquer davantage la tâche d'un analyste.
